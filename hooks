#!/bin/bash

# Git Hooks Management Script
# Provides easy management of Husky hooks

set -e

HOOKS_DIR=".husky"
SCRIPTS_DIR="$HOOKS_DIR/scripts"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

# Check if we're in a git repository
check_git_repo() {
    if [ ! -d ".git" ]; then
        print_error "Not a Git repository"
        echo "   Run 'git init' first"
        exit 1
    fi
}

# Command: setup
cmd_setup() {
    print_header "ü™ù Setting up Git hooks with Husky..."

    check_git_repo

    # Check if Husky is already initialized
    if [ -f "$HOOKS_DIR/_/husky.sh" ]; then
        print_warning "Husky already initialized"
        return
    fi

    # Install dependencies if not present
    if ! command -v husky &> /dev/null; then
        print_error "Husky not found. Install with: bun add -d husky"
        exit 1
    fi

    # Initialize Husky
    print_info "Initializing Husky..."
    npx husky init

    # Create scripts directory
    mkdir -p "$SCRIPTS_DIR"

    print_success "Husky setup complete"
    echo ""
    echo "üìÇ Hook structure created:"
    echo "   $HOOKS_DIR/"
    echo "   ‚îú‚îÄ‚îÄ pre-commit      (quality checks)"
    echo "   ‚îú‚îÄ‚îÄ commit-msg      (message validation)"
    echo "   ‚îú‚îÄ‚îÄ pre-push        (comprehensive tests)"
    echo "   ‚îî‚îÄ‚îÄ scripts/        (custom hook logic)"
}

# Command: list
cmd_list() {
    print_header "üìã Installed Git Hooks"

    echo ""

    # Active hooks
    echo "Active Hooks:"
    for hook in "$HOOKS_DIR"/pre-* "$HOOKS_DIR"/commit-msg "$HOOKS_DIR"/post-*; do
        if [ -f "$hook" ]; then
            name=$(basename "$hook")
            size=$(wc -l < "$hook")
            echo "  ‚úì $name ($size lines)"
        fi
    done

    echo ""
    echo "Custom Scripts:"
    if [ -d "$SCRIPTS_DIR" ]; then
        for script in "$SCRIPTS_DIR"/*.sh; do
            if [ -f "$script" ]; then
                name=$(basename "$script")
                echo "  -  $name"
            fi
        done
    else
        echo "  (none)"
    fi

    echo ""
    print_header ""
}

# Command: add
cmd_add() {
    HOOK_NAME="$1"

    if [ -z "$HOOK_NAME" ]; then
        print_error "Usage: ./hooks --add <hook-name>"
        exit 1
    fi

    print_info "Creating custom hook: $HOOK_NAME"

    cat > "$SCRIPTS_DIR/$HOOK_NAME.sh" << 'EOF'
#!/bin/bash
# Custom hook: {{HOOK_NAME}}
# TODO: Implement your check logic
#

echo "  -  Running {{HOOK_NAME}}..."

# Your logic here
# Example: Check for TODO comments

FILES=$(git diff --cached --name-only --diff-filter=ACM)

for file in $FILES; do
    if grep -qE "TODO:|FIXME:" "$file" 2>/dev/null; then
        echo "    ‚ö†Ô∏è  Found TODO/FIXME in: $file"
    fi
done

echo "    ‚úì Check complete"
exit 0
EOF

    # Replace placeholder
    sed -i.bak "s/{{HOOK_NAME}}/$HOOK_NAME/g" "$SCRIPTS_DIR/$HOOK_NAME.sh" && rm "$SCRIPTS_DIR/$HOOK_NAME.sh.bak"

    chmod +x "$SCRIPTS_DIR/$HOOK_NAME.sh"

    print_success "Custom hook created: $SCRIPTS_DIR/$HOOK_NAME.sh"
    echo "   Add to pre-commit: $SCRIPTS_DIR/$HOOK_NAME.sh"
}

# Command: test
cmd_test() {
    print_header "üß™ Testing Git Hooks"

    # Test pre-commit
    echo ""
    echo "Testing pre-commit hook..."
    if [ -f "$HOOKS_DIR/pre-commit" ]; then
        if "$HOOKS_DIR/pre-commit"; then
            print_success "pre-commit: PASS"
        else
            print_error "pre-commit: FAIL"
        fi
    else
        print_warning "pre-commit: NOT FOUND"
    fi

    # Test commit-msg with sample
    echo ""
    echo "Testing commit-msg hook..."
    if [ -f "$HOOKS_DIR/commit-msg" ]; then
        echo "feat(test): test commit message" > /tmp/test-commit-msg
        if "$HOOKS_DIR/commit-msg" /tmp/test-commit-msg; then
            print_success "commit-msg: PASS"
        else
            print_error "commit-msg: FAIL"
        fi
        rm -f /tmp/test-commit-msg
    else
        print_warning "commit-msg: NOT FOUND"
    fi

    # Test pre-push
    echo ""
    echo "Testing pre-push hook..."
    if [ -f "$HOOKS_DIR/pre-push" ]; then
        # Create a simple test - just check if script runs without error
        if timeout 5 "$HOOKS_DIR/pre-push" 2>/dev/null; then
            print_success "pre-push: PASS (timeout after 5s)"
        else
            print_error "pre-push: FAIL"
        fi
    else
        print_warning "pre-push: NOT FOUND"
    fi

    echo ""
    print_header "Test Results Complete"
}

# Command: disable
cmd_disable() {
    print_info "‚è∏  Disabling Git hooks..."

    # Rename hooks to disable
    for hook in "$HOOKS_DIR"/pre-* "$HOOKS_DIR"/commit-msg; do
        if [ -f "$hook" ]; then
            mv "$hook" "$hook.disabled"
            echo "  -  Disabled: $(basename "$hook")"
        fi
    done

    echo ""
    print_success "Hooks disabled"
    echo "   Re-enable with: ./hooks --enable"
}

# Command: enable
cmd_enable() {
    print_info "‚ñ∂Ô∏è  Re-enabling Git hooks..."

    # Rename hooks back
    for hook in "$HOOKS_DIR"/*.disabled; do
        if [ -f "$hook" ]; then
            original_name=$(basename "$hook" .disabled)
            mv "$hook" "$HOOKS_DIR/$original_name"
            echo "  -  Enabled: $original_name"
        fi
    done

    echo ""
    print_success "Hooks re-enabled"
}

# Command: status
cmd_status() {
    print_header "üìä Hook Status"

    echo ""

    # Check if hooks are enabled/disabled
    enabled_count=0
    disabled_count=0

    for hook in pre-commit commit-msg pre-push; do
        if [ -f "$HOOKS_DIR/$hook" ]; then
            echo "  ‚úì $hook: ENABLED"
            enabled_count=$((enabled_count + 1))
        elif [ -f "$HOOKS_DIR/$hook.disabled" ]; then
            echo "  ‚è∏Ô∏è  $hook: DISABLED"
            disabled_count=$((disabled_count + 1))
        else
            echo "  ‚ùå $hook: MISSING"
        fi
    done

    echo ""
    echo "Summary: $enabled_count enabled, $disabled_count disabled"

    echo ""
    print_header ""
}

# Main command dispatcher
case "$1" in
    --setup)
        cmd_setup
        ;;
    --list)
        cmd_list
        ;;
    --add)
        cmd_add "$2"
        ;;
    --test)
        cmd_test
        ;;
    --disable)
        cmd_disable
        ;;
    --enable)
        cmd_enable
        ;;
    --status)
        cmd_status
        ;;
    *)
        echo "Git Hooks Management Script"
        echo ""
        echo "Usage:"
        echo "  ./hooks --setup           Setup Husky hooks"
        echo "  ./hooks --list            List all hooks"
        echo "  ./hooks --add <name>      Add custom hook"
        echo "  ./hooks --test            Test hooks without committing"
        echo "  ./hooks --disable         Temporarily disable hooks"
        echo "  ./hooks --enable          Re-enable disabled hooks"
        echo "  ./hooks --status          Show hook status"
        echo ""
        echo "Examples:"
        echo "  ./hooks --setup"
        echo "  ./hooks --add check-todos"
        echo "  ./hooks --test"
        exit 1
        ;;
esac